---
title: "Food Supply"
author: "Vittorio Giorgio Candolo"
output: 
  ioslides_presentation: 
    css: style.css
    incremental: yes
    widescreen: yes
---

<style type="text/css">
slides > slide:not(.nobackground):after {content: '';}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE)
```

```{r libraries, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(tibble)
library(readr)
library(tidyr)
library(dplyr)
library(knitr)
library(geojsonsf)
library(sf)
library(scales)
library(leaflet)
library(mapview)
library(viridis)
library(kableExtra)
library(plotly)
library(ggplot2)
library(RColorBrewer)
```

# Project

## Il progetto

Per il mio progetto di data science ho scelto il tema della produzione e distribuzione del cibo sui mercati internazionali.

Mi concentrerò sull'aspetto della produzione e distribuzione della materia prima e non sulle connotazioni economiche del fenomeno.  
Riferimenti all'economia potranno però essere talvolta presenti, così come sono presenti riferimenti a condizioni geografiche o sociali che hanno effetti più o meno diretti sui dati trattati.

L'analisi parte dalla visualizzazione di un dato che ho sfruttato io stesso per orientarmi.  
In seguito si cercano nei dati risposte a quesiti sorti proprio osservando questo modello iniziale.  
La parte finale del progetto è dedicata ad alcune considerazioni generali sul tema della sostenibilità della produzione.

# Data

## FAOSTAT

I dataset di partenza sono stati ottenuti dal sito della [FAO](https://www.fao.org/faostat/en/#data), organizzazione ONU che si occupa di cibo e agricoltura.

L'organizzazione è responsabile dei dati raccolti nei paesi membri e si occupa anche della loro validazione e diffusione.  
<img src="./media/faostat.png" alt="FAOSTAT data web page" width="420" style="margin: 25px"/>

## I dataset

I dataset utilizzati sono:

```{r csvList, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
csvList <- list.files("./data/", pattern = ".csv$")
csvList
```
La maggior parte sono stati ottenuti tramite l'opzione di bulk download offerta dal sito FAOSTAT.
Solo in alcuni casi tramite interrogazioni poste al sistema stesso per motivi di formati e compatibilità.  
I dataset 1 e 7 sono invece accessori, necessari per alcune visualizzazioni.

# Food Balance

```{r BoT, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building a df for the world BoT map

# importing dataset
boT <- read_csv("./data/FoodBalanceSheets_E_All_Data.csv") %>%
  # selecting only the columns we need
  select(Area, Item, Element, Y2017, Y2018, Y2019) %>%
  # filtering export and import
  filter(Element == "Export Quantity" | Element == "Import Quantity") %>%
  # grouping so that we get can get one entry per state after using pivot_wider
  # we use 3-year average like FAO
  group_by(Area, Element) %>%
  summarize(Quantity = sum(Y2017, Y2018, Y2019, na.rm=TRUE)/3)

boT <- pivot_wider(boT, names_from = Element, values_from = Quantity) %>%
  # making a derived column for ease
  mutate(`bot` = `Export Quantity` - `Import Quantity`) %>%
  # minimal selection
  select(Area, bot) %>%
  rename(country = Area)

# ungrouping
boT <- ungroup(boT)

# normalization so that it works better with the palette but without distortion
minBoT <- min(boT$bot)
maxBoT <- max(boT$bot)
boT <- mutate(boT, botNorm =
                    (bot - minBoT) / (maxBoT - minBoT))

# rounding the to be displayed column
boT <- mutate_at(boT, vars(bot), funs(round(., 0)))

# importing geographic data
borders <- geojson_sf("./data/countries.geojson")

# fixing country name mismatches

# let's find conflicts
countriesToFix <- anti_join(boT, borders, by = c("country" = "ADMIN"))

# fixing
boT[boT == "Bahamas"] <- "The Bahamas"
boT[boT == "Bolivia (Plurinational State of)"] <- "Bolivia"
boT[boT == "China, Hong Kong SAR"] <- "Hong Kong S.A.R."
boT[boT == "China, Macao SAR"] <- "Macao S.A.R"
boT[boT == "China, mainland"] <- "China"
boT[boT == "China, Taiwan Province of"] <- "Taiwan"
boT[boT == "Cabo Verde"] <- "Cape Verde"
boT[boT == "Congo"] <- "Republic of Congo"
boT[boT == "Cote d'Ivoire"] <- "Ivory Coast"
boT[boT == "Czechia"] <- "Czech Republic"
boT[boT == "Democratic People's Republic of Korea"] <- "North Korea"
boT[boT == "Eswatini"] <- "Swaziland"
boT[boT == "Guinea-Bissau"] <- "Guinea Bissau"
boT[boT == "Iran (Islamic Republic of)"] <- "Iran"
boT[boT == "Lao People's Democratic Republic"] <- "Laos"
boT[boT == "Micronesia"] <- "Federated States of Micronesia"
boT[boT == "Netherlands Antilles (former)"] <- "Curaçao" # 0
boT[boT == "North Macedonia"] <- "Macedonia"
boT[boT == "Republic of Korea"] <- "South Korea"
boT[boT == "Republic of Moldova"] <- "Moldova"
boT[boT == "Russian Federation"] <- "Russia"
boT[boT == "Serbia"] <- "Republic of Serbia"
boT[boT == "Syrian Arab Republic"] <- "Syria"
boT[boT == "Timor-Leste"] <- "East Timor"
boT[boT == "United Kingdom of Great Britain and Northern Ireland"] <- "United Kingdom"
boT[boT == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"
boT[boT == "Viet Nam"] <- "Vietnam"

# removing aggregate entry for China
boT = boT[-39,]

# removing entry with no data for former Sudan
boT = boT[-185,]

# left outer join between our df and the geographic data
borders <- left_join(borders, boT, by = c("ADMIN" = "country"))

# building the map

# setting the palette
palette <- colorBin("viridis", borders$botNorm)

# making labels
labels <- sprintf("<strong>%s</strong><br/>%s K MT", borders$ADMIN,
                  format(round(as.numeric(borders$bot), 1), nsmall=1, big.mark=",")) %>%
  lapply(htmltools::HTML)

# entries for custom legend
legendLabels <- tibble(
  "- 300,000", "- 240,000", "- 180,000", "- 120,000", "- 60,000", "0",  "+ 75,000", "+ 150,000", "+ 225,000", "+ 300,000"
  )

# actual building
mapBoT <- leaflet(borders , options = leafletOptions(minZoom = 2.1), width = "100%") %>%
  addTiles() %>%
  setView(15, 20, 2) %>%
  addPolygons(
    data = borders, 
    color = '#ffffff', 
    weight = 1, 
    opacity = 0.5, 
    fillColor = ~palette(botNorm), 
    fillOpacity = 0.7, 
    highlight = highlightOptions(weight = 5), 
    label = labels
    ) %>%
    # legend
    addLegend("bottomright", pal = palette, values = ~botNorm, title = "BoT (K MT)", opacity = 1, labFormat = 
              function(type, cuts, p) {paste0(legendLabels)}
  )
```

## Bilancia commerciale

Come punto di ingresso dell'analisi sfrutteremo il dataset relativo al Balance of Trade (BoT) degli stati.  
Il BoT è dato dalla differenza (in migliaia di tonnellate) tra il totale delle esportazioni e il totale delle importazioni.

Il dataset di partenza è stato elaborato in modo da poter costruire una mappa interattiva che permette di riconoscere il ruolo degli stati nell'offerta globale del cibo.

I dati di riferimento su esportazioni e importazioni sono calcolati come medie triennali.  
È stata attuata una normalizzazione min-max sui dati per ottimizzarne la rappresentazione.

## Mappa mondiale del BoT

```{r mapBoT, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

mapBoT 
```

## Alcune considerazioni

Cercheremo nei dati risposta a quesiti relativi ai punti in grassetto.

* In Europa Occidentale solo la Francia è esportatore netto
* Gli stati dell'Europa Orientale sono generalmente esportatori
* __I due paesi più popolosi (Cina e India) presentano situazioni diverse__
* Tutti i paesi mediorientali sono importatori netti
* __Molti stati africani hanno bilanci prossimi alla neutralità__
* Tutti i paesi dell'Oceania sono esportatori netti
* __Gli Stati Uniti esportano più del Canada__
* __Il Brasile è il massimo esportatore netto__

# Supply Utilization Accounts

```{r SUA, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building dfs to analyze food production and consumption in China and India

# importing dataset
sUA <- read_csv("./data/SUA_Crops_Livestock_E_Asia.csv") %>%
  # selecting only the columns we need
  select(Area, Item, Element, Unit, Y2017, Y2018, Y2019) %>%
  # 3-year average
  group_by(Area, Item, Element, Unit) %>%
  summarize(Quantity = sum(Y2017, Y2018, Y2019, na.rm=TRUE)/3) %>%
  rename(country = Area, item = Item, element = Element, unit = Unit, quantity = Quantity)

# ungrouping
sUA <- ungroup(sUA)

# filtering China
sUAChina <- filter(sUA,
                       country == "China, Hong Kong SAR" |
                       country == "China, Macao SAR" | 
                       country == "China, mainland" | 
                       country == "China, Taiwan Province of"
                       )
                       
# aggregating data
sUAChina <- group_by(sUAChina, item, element, unit) %>%
  summarize(country = "China", quantity = sum(quantity))

# ungrouping and minimal selection
sUAChina <- ungroup(sUAChina) %>%
  select(-country)

# filtering India
sUAIndia <- filter(sUA, country == "India")

# ungrouping and minimal selection
sUAIndia <- ungroup(sUAIndia) %>%
  select(-country)

# filtering production output for China
sUAChinaP <- filter(sUAChina, element == "Production") %>%
  # minimal selection
  select(item, quantity) %>%
  # arranging for display
  arrange(desc(quantity))

# preparing for join
sUAChinaP <- rename(sUAChinaP, `chineseProduction` = quantity)
  
# filtering production output for India
sUAIndiaP <- filter(sUAIndia, element == "Production") %>%
  # minimal selection
  select(item, quantity) %>%
  # arranging for display
  arrange(desc(quantity))

# preparing for join
sUAIndiaP <- rename(sUAIndiaP, indianProduction = quantity)
 
# join
sUAP <- inner_join(sUAChinaP, sUAIndiaP)

# excluding aggregate and redundant entries
sUAP <- filter(sUAP,!(grepl('Total', item))) %>%
  filter(!(grepl('Primary', item))) %>%
  filter(!(grepl('Incl', item))) %>%
  filter(!(grepl(',', item)))

# computing totals
cPTot = sum(sUAP$chineseProduction)
iPTot = sum(sUAP$indianProduction)

# building interactive bar-plot

# margins
m <- list(
  l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 4
)

# China trace
barSUAP <- plot_ly(
  sUAP,
  x = ~item,
  y = ~chineseProduction,
  type = 'bar',
  name = 'China',
  marker = list(color = 'rgb(102,51,153)')
  )

# India trace
barSUAP <- barSUAP %>%
  add_trace(
    y = ~indianProduction,
    name = 'India',
    marker = list(color = 'rgb(102,204,153)')
    )

# layout
barSUAP <- barSUAP %>%
  layout(xaxis = list(title = 'Item', showticklabels=FALSE),
         yaxis = list(title = 'Tonnes'),
         autosize = F, 
         width = 1000, 
         height = 500, 
         margin = m,
         barmode = 'group',
         hovermode='x')

# adding totals
sUAP <- rbind(list("Total", cPTot, iPTot), sUAP) %>%
# arrangement so that we show totals first
  arrange(desc(chineseProduction)) %>%
  # readable format
  mutate_at(
    vars(chineseProduction, indianProduction),
    funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))
    )

# filtering consumption for China
sUAChinaC <- filter(sUAChina,
                    element == "Export Quantity" | 
                    element == "Feed" | 
                    element == "Processed" | 
                    element == "Loss" |
                    element == "Food supply quantity (tonnes)" |
                    element == "Other uses (non-food)") %>%
  # minimal selection
  select(-unit)

# pivot-wider to make it tidy
sUAChinaC <- pivot_wider(sUAChinaC, names_from = element, values_from = quantity)

# excluding aggregate and redundant entries
sUAChinaC <- filter(sUAChinaC,!(grepl('Total', item))) %>%
  filter(!(grepl('Primary', item))) %>%
  filter(!(grepl('Incl', item))) %>%
  filter(!(grepl(',', item))) %>%
  # making an aggregate column for total consumption
  group_by(item, `Export Quantity`) %>%
  summarize(`Consumption Quantity` = sum(
    `Feed`,
    `Processed`,
    `Loss`,
    `Food supply quantity (tonnes)`,
    `Other uses (non-food)`, na.rm=TRUE), across()) %>%
  arrange(desc(`Consumption Quantity`)) %>%
  rename(
    exportQuantity = `Export Quantity`,
    consumptionQuantity = `Consumption Quantity`,
    otherUsesNonFood = `Other uses (non-food)`,
    foodSupplyQuantity = `Food supply quantity (tonnes)`,
    loss = Loss,
    processed = Processed,
    feed = Feed)

# ungrouping
sUAChinaC <- ungroup(sUAChinaC)
  
# filtering consumption for India
sUAIndiaC <- filter(sUAIndia, 
                    element == "Export Quantity" | 
                    element == "Feed" | 
                    element == "Processed" | 
                    element == "Loss" | 
                    element == "Food supply quantity (tonnes)" |
                    element == "Other uses (non-food)") %>%
  # minimal selection
  select(-unit)

# pivot-wider to make it tidy
sUAIndiaC <- pivot_wider(sUAIndiaC, names_from = element, values_from = quantity)
 
# excluding aggregate and redundant entries
sUAIndiaC <- filter(sUAIndiaC,!(grepl('Total', item))) %>%
  filter(!(grepl('Primary', item))) %>%
  filter(!(grepl('Incl', item))) %>%
  filter(!(grepl(',', item))) %>%
  # making an aggregate column for total consumption
  group_by(item, `Export Quantity`) %>%
  summarize(`Consumption Quantity` = sum(
    `Feed`,
    `Processed`,
    `Loss`,
    `Food supply quantity (tonnes)`,
    `Other uses (non-food)`, na.rm=TRUE), across()) %>%
  arrange(desc(`Consumption Quantity`)) %>%
  rename(
    exportQuantity = `Export Quantity`,
    consumptionQuantity = `Consumption Quantity`,
    otherUsesNonFood = `Other uses (non-food)`,
    foodSupplyQuantity = `Food supply quantity (tonnes)`,
    loss = Loss,
    processed = Processed,
    feed = Feed)

# ungrouping
sUAIndiaC <- ungroup(sUAIndiaC)

# computing totals
cCTot = sum(sUAChinaC$consumptionQuantity, na.rm = TRUE)
iCTot = sum(sUAIndiaC$consumptionQuantity, na.rm = TRUE)

# China consumption plot
scatterSUAChinaC <- plot_ly(
  sUAChinaC,
  x = ~exportQuantity,
  y = ~consumptionQuantity,
  size = ~foodSupplyQuantity,
  color = ~item,
  colors = c("#440154", "#46327e", "#365c8d", "#277f8e", "#1fa187", "#4ac16d", "#a0da39", "#fde725"),
  hovermode = "x",
  type = 'scatter',
  mode = 'markers'
  )

# layout
scatterSUAChinaC <- scatterSUAChinaC %>%
  layout(
    showlegend = FALSE,
    xaxis = list(title = 'Consumption'),
    yaxis = list(title = 'Export')
    )

# India consumption plot
scatterSUAIndiaC <- plot_ly(
  sUAIndiaC,
  x = ~exportQuantity,
  y = ~consumptionQuantity,
  size = ~foodSupplyQuantity,
  color = ~item,
  colors = c("#440154", "#46327e", "#365c8d", "#277f8e", "#1fa187", "#4ac16d", "#a0da39", "#fde725"),
  hovermode = "x",
  type = 'scatter',
  mode = 'markers'
  )

# layout
scatterSUAIndiaC <- scatterSUAIndiaC %>%
  layout(
    showlegend = FALSE,
    xaxis = list(title = 'Consumption'),
    yaxis = list(title = 'Export')
    )
```

## Cina e India a confronto

Si tratta di due stati grandi e molto popolosi.  
Mentre la Cina è il più grande importatore netto di cibo al mondo, l'India ha invece una bilancia commerciale positiva.

Per capire le ragioni di questa differenza analizzeremo la produzione e il consumo di cibo nei due paesi.

Ci serviremo di un dataset diverso, incentrato sulla contabilità alimentare degli stati (Supply Utilization Accounts).

## Produzione

Per prima cosa verifichiamo che a causare le grandi importazioni cinesi non sia una produzione alimentare inadeguata al sostentamento della sua popolazione  
(che è solo sensibilmente maggiore rispetto a quella indiana).

Il seguente grafico confronta l'output produttivo dei due paesi per ogni categoria di alimento.

```{r barSUAP, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

barSUAP
```

## Produzione

Come emerge navigando il grafico, nonostante alcuni settori in cui l'India è specializzata, la produzione di cibo in Cina è globalmente superiore.  
La Cina è infatti (come vedremo in seguito) il più grande produttore di cibo al mondo, seguita proprio dall'India.

Le quantità sono espresse in tonnellate.

```{r sUAP, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# disabling scientific notation
options(scipen=999)

# building the table
sUAP %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "500px")
```

## Consumi

Chiarito che non è l'output produttivo a determinare la condizione cinese non ci resta che esplorare l'aspetto dei consumi.

Sfrutteremo un'opportuna rielaborazione del dataset usato in precedenza.  
Tutte le quantità seguenti sono in tonnellate.

Cina:

Consumi totali:

```{r cTot, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# readable format
format(round(as.numeric(cCTot), 1), nsmall=1, big.mark=",")
```

```{r sUAChinaC, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# disabling scientific notation
options(scipen=999)

# building table
sUAChinaC %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "500px")
```

<br>
India:

Consumi totali:

```{r iCTot, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# readable format
format(round(as.numeric(iCTot), 1), nsmall=1, big.mark=",")
```

```{r sUAIndiaC, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# disabling scientific notation
options(scipen=999)

# building table
sUAIndiaC %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "500px")
```

## Consumi

Emerge che i consumi indiani sono notevolmente inferiori.

Nei grafici successivi andremo a vedere la relazione tra export e consumi per ogni alimento.

La dimensione del punto dipende dal consumo umano dell'alimento.

Cina:

```{r scatterSUAChinaC, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterSUAChinaC
```

<br>
India:

```{r scatterSUAIndiaC, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterSUAIndiaC
```

<br>
Possiamo quindi concludere che la differenza evidenziata dalla mappa è da ricondurre in primo luogo ad un maggiore consumo interno della produzione in Cina e in secondo luogo ad una propensione alla quasi totale esportazione di alcune produzioni in India.

# Area, population and GDP

```{r APopGDP, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building a df for Africa to study correlation between BoT and area, population and GDP

# importing countries data (ISO3 format)
iso <- read_csv("./data/lukes_ISO-3166-Countries-with-Regional-Codes.csv") %>%
  # preparing for join
  rename(country = name) %>%
  # filtering only african countries
  filter((grepl('Africa', `region`)))

# fixing names
iso[iso == "Cabo Verde"] <- "Cape Verde"
iso[iso == "Congo"] <- "Republic of Congo"
iso[iso == "Côte d'Ivoire"] <- "Ivory Coast"
iso[iso == "Eswatini"] <- "Swaziland"
iso[iso == "Guinea-Bissau"] <- "Guinea Bissau"
iso[iso == "Timor-Leste"] <- "East Timor"

# join so that we get BoT + geographical info for every african state
boTA <- inner_join(iso, boT)

# selecting only the columns we need
boTA <- select(boTA, country, region, `sub-region`, `intermediate-region`, bot)

# building bar plot
boxBoTA <- ggplot(data = boTA) +
  geom_boxplot(mapping = aes(x = `intermediate-region`, y = bot,  fill = `sub-region`)) +
  labs(
    title = "BoT Africa per regione",
    subtitle = "Intermediate-region =  NA per gli stati della Northern Africa",
    caption = "Gli outsider sono più grandi, popolosi e ricchi",
    x = "Intermediate-region"
  )

# importing area data from a new dataset (we need ISO3 names)
wHa <- read_csv("./data/Inputs_LandUse_E_All_Data.csv") %>%
  # selection only the columns we need
  select(`Area Code (ISO3)`, `Value`) %>%
  # preparing for join and renaming with unit in column title
  rename(cCode = `Area Code (ISO3)`, area = Value)

# importing population data from a new dataset (we need ISO3 names)
wpop <- read_csv("./data/Population_E_All_Data.csv") %>%
  # selection only the columns we need
  select(`Area Code (ISO3)`, `Value`) %>%
  # preparing for join and renaming with unit in column title
  rename(cCode = `Area Code (ISO3)`, population = Value)

# importing dataset with GDP data
wgdp <- read_csv("./data/API_NY.GDP.MKTP.CD_DS2_en_csv_v2_4413598.csv") %>%
  # selecting only the columns we need, 2018 is last year with every state in FAO data
  select(`Country Name`, `Country Code`, `2018`) %>%
  # preparing for next join and renaming
  rename(country = `Country Name`, cCode = `Country Code`, gdp = `2018`) %>%
  # removing aggregate country codes...
  filter(!(grepl('AFE', cCode))) %>%
  filter(!(grepl('AFW', cCode))) %>%
  filter(!(grepl('ARB', cCode))) %>%
  filter(!(grepl('CEB', cCode))) %>%
  filter(!(grepl('EAP', cCode))) %>%
  filter(!(grepl('EAR', cCode))) %>%
  filter(!(grepl('EAS', cCode))) %>%
  filter(!(grepl('ECA', cCode))) %>%
  filter(!(grepl('ECS', cCode))) %>%
  filter(!(grepl('EMU', cCode))) %>%
  filter(!(grepl('EUU', cCode))) %>%
  filter(!(grepl('FCS', cCode))) %>%
  filter(!(grepl('HIC', cCode))) %>%
  filter(!(grepl('HPC', cCode))) %>%
  filter(!(grepl('IBD', cCode))) %>%
  filter(!(grepl('IBT', cCode))) %>%
  filter(!(grepl('IDA', cCode))) %>%
  filter(!(grepl('IDB', cCode))) %>%
  filter(!(grepl('AFE', cCode))) %>%
  filter(!(grepl('IDX', cCode))) %>%
  filter(!(grepl('LAC', cCode))) %>%
  filter(!(grepl('LCN', cCode))) %>%
  filter(!(grepl('LDC', cCode))) %>%
  filter(!(grepl('LIC', cCode))) %>%
  filter(!(grepl('LMC', cCode))) %>%
  filter(!(grepl('LMY', cCode))) %>%
  filter(!(grepl('LTE', cCode))) %>%
  filter(!(grepl('MEA', cCode))) %>%
  filter(!(grepl('MIC', cCode))) %>%
  filter(!(grepl('MNA', cCode))) %>%
  filter(!(grepl('NAC', cCode))) %>%
  filter(!(grepl('OED', cCode))) %>%
  filter(!(grepl('OSS', cCode))) %>%
  filter(!(grepl('PRE', cCode))) %>%
  filter(!(grepl('PST', cCode))) %>%
  filter(!(grepl('SAS', cCode))) %>%
  filter(!(grepl('SSA', cCode))) %>%
  filter(!(grepl('SSF', cCode))) %>%
  filter(!(grepl('SST', cCode))) %>%
  filter(!(grepl('TEA', cCode))) %>%
  filter(!(grepl('TEC', cCode))) %>%
  filter(!(grepl('TLA', cCode))) %>%
  filter(!(grepl('TMN', cCode))) %>%
  filter(!(grepl('TSA', cCode))) %>%
  filter(!(grepl('TSS', cCode))) %>%
  filter(!(grepl('UMC', cCode))) %>%
  filter(!(grepl('WLD', cCode)))

# join
popGdp <- inner_join(wpop, wgdp)

# join
popGdpBoT <- inner_join(boT, popGdp)

# final join
correlation <- inner_join(popGdpBoT, wHa) %>%
  # dropping column used for joins
  select(-botNorm, -cCode)

# mutated df for alternative visualization
correlationAbs <- mutate_if(correlation, is.numeric, funs(abs(.)))

# building area scatter plot
scatterBoTSu <- ggplot(data = correlation, mapping = aes(x = area,  y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT - area",
    subtitle = "Il dato della Cina influenza fortemente la linea di tendenza",
    caption = "Dati 2020 per la superificie degli stati",
    x = "Area (1000 ha)"
  )

# building area scatter plot with abs(BoT)
scatterBoTSuAbs <- ggplot(data = correlationAbs, mapping = aes(x = area, y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT (abs) - area",
    subtitle = "Emerge correlazione",
    caption = "Dati 2020 per la superificie degli stati",
    x = "Area (1000 ha)",
    y = "Balance of Trade (K MT) (abs)"
  )

# building population scatter plot
scatterBoTPop <- ggplot(data = correlation, mapping = aes(x = population, y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT - popolazione",
    subtitle = "I valori di Cina e India influenzano fortemente la linea di tendenza",
    caption = "Dati 2018 per la popolazione degli stati"
  )

# building population scatter plot with abs(BoT)
scatterBoTPopAbs <- ggplot(data = correlationAbs, mapping = aes(x = population, y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT (abs) - popolazione",
    subtitle = "Il dato dell'India influenza fortemente la linea di tendenza",
    caption = "Dati 2018 per la popolazione degli stati",
    y = "Balance of Trade (K MT) (abs)"
  )

# building gdp scatter plot
scatterBoTGDP <- ggplot(data = correlation, mapping = aes(x = gdp, y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT - GDP",
    subtitle = "Da notare l'andamento della curva",
    caption = "Dati 2018 per il GDP degli stati",
  )

# building gdp scatter plot with abs(BoT)
scatterBoTGDPAbs <- ggplot(data = correlationAbs, mapping = aes(x = gdp, y = bot)) +
  geom_point() + 
  geom_smooth() +
  labs(
    title = "Correlazione BoT (abs) - GDP",
    subtitle = "Si conferma l'andamento precedente",
    caption = "Dati 2018 per il GDP degli stati",
    y = "Balance of Trade (K MT) (abs)"
  )
```

## L'Africa subsahariana

Il bilancio commerciale è a livello globale ovviamente un gioco a somma zero.  
Anche a livello continentale questa caratteristica generalmente si mantiene per fattori geografici, politici e culturali.

Una notevole eccezione si verifica però in Africa dove gli stati subsahariani sono caratterizzati da BoT dal valore assoluto contenuto mentre gli stati del Nord sono forti importatori.

```{r boxBoTA, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

boxBoTA
```

## Correlazione

Gli stati del Nord Africa sono certamente favoriti nel commercio tramite il Mediterraneo ma sono anche in media più estesi, popolosi e ricchi rispetto agli altri stati del continente.

L'ipotesi naturale per spiegare il valore modesto dei bilanci commerciali degli stati subsahariani è che ciò sia dovuto al fatto che si tratta spesso di stati piccoli, poco popolati e poco sviluppati.

Il BoT è però un dato complesso per cui vale la pena di analizzare tramite scatter plot eventuali correlazioni.

## BoT - area

```{r scatterBoTSu, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTSu
```

<br>

```{r scatterBoTSuAbs, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTSuAbs
```

## BoT - popolazione

```{r scatterBoTPop, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTPop
```

<br>

```{r scatterBoTPopAbs, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTPopAbs
```

## BoT - GDP

```{r scatterBoTGDP, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTGDP
```

<br>

```{r scatterBoTGDPAbs, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterBoTGDPAbs
```

# Population, land and production

```{r popLandProd, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building dfs to analyze the differences between Canada and the USA (population, land and production)

# importing data (poplation df)
pop <- read_csv("./data/Population_E_Americas.csv") %>%
  # selecting only the columns we need
  select(Area, Element, Value) %>%
  # pivot-wider to make it tidy
  pivot_wider(names_from = Element, values_from = Value) %>%
  select(Area, `Total Population - Both sexes`, `Rural population`, `Urban population`) %>%
  # for visualization
  arrange(desc(`Total Population - Both sexes`)) %>%
  rename(
    country = Area,
    totalPopulation = `Total Population - Both sexes`,
    ruralPopulation = `Rural population`,
    urbanPopulation = `Urban population`
  )

# building scatter plot to compare urbanization
scatterPopAm <- ggplot(pop[1:8, ], aes(urbanPopulation, ruralPopulation)) +
  geom_point(aes(colour = country)) +
  geom_smooth(method = "lm") +
  scale_color_brewer(palette="Dark2") +
  labs(
    title = "Rapporto tra popolazione urbana e rurale",
    subtitle = "Si noti il posizionamento degli stati rispetto alla linea di tendenza (lm)",
    caption = "Dati 2018"
  )

# importing data (census df)
cens <- read_csv("./data/Word_Census_Agriculture_E_Americas.csv") %>%
  # selecting only the columns we need
  select(Area, Item, Element, Value) %>%
  # pivot-wider
  pivot_wider(names_from = c(Item, Element), values_from = Value) %>%
  # selecting to make it tidy
  select(Area, Holdings_Area, `Holdings_Average area`, Holdings_Number) %>%
  # for visualization
  arrange(desc(`Holdings_Area`)) %>%
  rename(
    country = Area,
    holdingsArea = `Holdings_Area`,
    holdingsAverageArea = `Holdings_Average area`,
    holdingsNumber = `Holdings_Number`
  )

# building scatter plot to analyze relation between holdings number and average area
scatterHaAm <- ggplot(cens[1:8, ], aes(holdingsNumber, holdingsAverageArea)) +
  geom_point(aes(colour = country)) +
  geom_smooth(method = "lm") +
  scale_color_brewer(palette="Dark2") +
  labs(
    title = "Rapporto tra il numero di aziene agricole e la loro area media",
    subtitle = "Come prevedibile c'è un rapporto inversalmente proporzionale",
    caption = "Dati da ultimo censimento FAO (2010-2013)"
  )

# importing data (production df)
prod <- read_csv("./data/Production_Crop_Livestock_E_Americas.csv") %>%
  # selecting only the columns we need
  select(Area, Item, Element, Unit, Value) %>%
  rename(
    country = Area,
    item = Item,
    element = Element,
    unit = Unit,
    value = Value
  )

# filtering Canada
prodCA <- filter(prod, country == "Canada")

# ungrouping and selection
prodCA <- ungroup(prodCA) %>%
  # selecting
  select(-country)

# filtering USA
prodUSA <- filter(prod, country == "United States of America")

# ungrouping and selection
prodUSA <- ungroup(prodUSA) %>%
  # selecting
  select(-country)

# production output for Canada
prodCAOut <- filter(prodCA, element == "Production") %>%
  select(item, value) %>%
  arrange(desc(value))

# preparing for join
prodCAOut <- rename(prodCAOut, canadianProduction = value)
  
# production output for USA
prodUSAOut <- filter(prodUSA, element == "Production") %>%
  select(item, value) %>%
  arrange(desc(value))

# preparing for join
prodUSAOut <- rename(prodUSAOut, americanProduction = value)
 
# join
prodOutCompareUC <- inner_join(prodCAOut, prodUSAOut)

# excluding aggregate and redundant entries
prodOutCompareUC <- filter(prodOutCompareUC,!(grepl('Total', item))) %>%
  filter(!(grepl('Primary', item))) %>%
  filter(!(grepl('Incl', item))) %>%
  filter(!(grepl(',', item)))

# computing totals
caPOTot = sum(prodOutCompareUC$`Canadian Production (tonnes)`)
usaPOTot = sum(prodOutCompareUC$`American Production (tonnes)`)

# building interactive bar-plot to display production output

# margins
m <- list(
  l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 4
)

# Canada trace
barProdAm <- plot_ly(
  prodOutCompareUC,
  x = ~item,
  y = ~canadianProduction,
  type = 'bar',
  name = 'Canada',
  marker = list(color = 'rgb(102,51,153)')
  )

# USA trace
barProdAm <- barProdAm %>%
  add_trace(
    y = ~americanProduction,
    name = 'USA',
    marker = list(color = 'rgb(102,204,153)'))

# layout
barProdAm <- barProdAm %>%
  layout(xaxis = list(title = 'Item', showticklabels=FALSE),
         yaxis = list(title = 'Tonnes'),
         autosize = F, 
         width = 1000, 
         height = 500, 
         margin = m,
         barmode = 'group',
         hovermode='x')

# transofrming df for further modeling
prod <- prod %>%
  filter(country == "Canada" | country == "United States of America") %>%
  filter(element == "Area harvested") %>%
  rename(area = value) %>%
  arrange(desc(area))

# building box plot to compare harvested area (top 5 crops)
boxProdAm <- ggplot(data = prod[1:10, ]) +
  geom_boxplot(mapping = aes(x = country, y = area,  fill = country)) +
  labs(
    title = "Area coltivata",
    subtitle = "Selezione delle prime 5 produzioni per paese",
    caption = "Dati 2020"
  )

# splitting
hACa <- filter(prod, country == "Canada")
hAUSA <- filter(prod, country == "United States of America")

# computing totals
caHaTot = sum(hACa$area, na.rm = TRUE)
usaHaTot = sum(hAUSA$area, na.rm = TRUE)
```

## Canada e USA

Analiziamo questi due stati occidentali molto sviluppati.

Gli Stati Uniti sono uno dei principali esportatori di cibo.  
Il Canada è invece uno stato molto esteso ma che per motivi climatici e di popolazione ha una produzione alimentare in linea con quella di stati ben più piccoli.

Iniziamo stabilendo qualche punto relativo a popolazione e sfruttamento delle risorse.  
Per farlo ci serviamo anche di alcuni nuovi dataset sempre di derivazione FAO (Population and Employement e World Agricultural Census).

## Popolazione

Mettiamo a confronto i due stati dal punto di vista della popolazione.

La popolazione è espressa in migliaia di persone.  
Nelle righe successive della tabella compaiono gli altri stati del continente come contesto.

```{r popT, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table with custom order
pop[c(1,6,2:5,7:56),] %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "500px")
```

## Popolazione e territorio

Questo grafico ci permette di visualizzare i modelli di organizzazione del territorio per quanto riguarda gli abitanti.

Gli stati selezionati sono fortemente urbanizzati (popolazione urbana >80%).

```{r scatterPopAm, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterPopAm
```

## Sfruttamento del territorio

Mettiamo a confronto i due stati dal punto di vista dello sfruttamento del territorio

Area espressa in ettari.  
Nelle righe successive della tabella compaiono gli altri stati del continente come contesto.

```{r censT, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table with custom order
cens[c(1,5,2:4,6:56),] %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

## Sfruttamento del territorio e produzione

Questo grafico ci permette di visualizzare i modelli di organizzazione del territorio per quanto riguarda la produzione alimentare.

```{r scatterHaAm, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterHaAm
```

## Produzione

In questo caso emerge ancor più chiaramente come ci sia un'enorme differenza tra la capacità produttiva dei due paesi.

Gli Stati Uniti sono infatti il terzo produttore mondiale di cibo, dopo i già trattati Cina e India.

```{r barProdAm, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

barProdAm
```

## Produzione e territorio

Possiamo quindi concludere che il Canada seppur caratterizzato da un bilancio commerciale positivo non può competere con la capacità produttiva e di export americana per motivi geografici, di popolazione e economici.

Area sfruttata a scopo agricolo Canada:

```{r caHaTot, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# making readable
format(round(as.numeric(caHaTot), 1), nsmall=1, big.mark=",")
```

Area sfruttata a scopo agricolo USA:

```{r usaHaTot, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# making readable
format(round(as.numeric(usaHaTot), 1), nsmall=1, big.mark=",")
```

Questo grafico mostra la area in ettari dedicata in Canada e in USA alle prime 5 produzioni di ciascuno stato

```{r boxProdAm, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

boxProdAm
```

# Trade Matrix

```{r tradeB, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building dfs to analyze Brazil as the country with the highest positive BoT

# importing data (production)
production <- read_csv("./data/FoodBalanceSheets_E_All_Data.csv") %>%
  # selecting only the columns we need
  select(Area, Element, Item, Unit, Y2018) %>%
  # filtering for production
  filter(Element == "Production") %>%
  # grouping by state
  group_by(Area) %>%
  summarize(`Production (tonnes)` = sum(Y2018, na.rm = TRUE)) %>%
  # arranging for visualization
  arrange(desc(`Production (tonnes)`)) %>%
  # ungrouping
  ungroup() %>%
  # renaming for visualization
  rename(country = Area, production = `Production (tonnes)`)

# a df so that we can easily remove aggregate entries
countryList <- select(borders, ADMIN) %>%
  rename(country = ADMIN)

# only way I found to be working to remove that column
countryList$geometry <- NULL

# removing aggregate entries
production <- inner_join(production, countryList)

# importing data (exports)
export <- read_csv("./data/Trade_CropsLivestock_E_All_Data.csv") %>%
  # selecting only the columns we need
  select(Area, Element, Item, Unit, Value) %>%
  # pivot-wider to make it tidy
  pivot_wider(names_from = c(Element, Unit), values_from = Value) %>%
  # grouping
  group_by(Area) %>%
  summarize(
    `Export Quantity_tonnes` = sum(`Export Quantity_tonnes`, na.rm=TRUE),
    `Export Quantity_No` = sum(`Export Quantity_No`, na.rm=TRUE),
    `Export Quantity_Head` = sum(`Export Quantity_Head`, na.rm=TRUE),
    `Export Quantity_1000 Head` = sum(`Export Quantity_1000 Head`, na.rm=TRUE),
    `Export Value_1000 US$` = sum(`Export Value_1000 US$`, na.rm=TRUE)
    ) %>%
  # for visualization
  arrange(desc(`Export Quantity_tonnes`)) %>%
  rename(
    country = Area,
    exportTonnes = `Export Quantity_tonnes`,
    exportN = `Export Quantity_No`,
    exportHead = `Export Quantity_Head`,
    export1000Head = `Export Quantity_1000 Head`,
    `exportValue1000US$` = `Export Value_1000 US$`
  )

  # importing data (trade matrix)
trade <- read_csv("./data/Trade_DetailedTradeMatrix_E_All_Data.csv") %>%
  # selecting only the columns we need
  select(`Partner Countries`, Element, Item, Value) %>%
  filter(Element == "Export Quantity") %>%
  group_by(`Partner Countries`) %>%
  summarize(Value = sum(Value, na.rm = TRUE)) %>%
  rename(country = `Partner Countries`, quantity = Value)

# normalization so that it works better with the palette but without distortion
minTrade <- min(trade$quantity)
maxTrade <- max(trade$quantity)
trade <- mutate(trade, qNorm =
                    (quantity - minTrade) / (maxTrade - minTrade))
  
# building export map
  
# geo data already imported

# fixing country name mismatches

# let's find conflicts
countriesToFix <- anti_join(trade, borders, by = c("country" = "ADMIN"))

# fixing
trade[trade == "Bahamas"] <- "The Bahamas"
trade[trade == "Brunei Darussalam"] <- "Brunei"
trade[trade == "Bolivia (Plurinational State of)"] <- "Bolivia"
trade[trade == "China, Hong Kong SAR"] <- "Hong Kong S.A.R."
trade[trade == "China, Macao SAR"] <- "Macao S.A.R"
trade[trade == "China, mainland"] <- "China"
trade[trade == "China, Taiwan Province of"] <- "Taiwan"
trade[trade == "Cabo Verde"] <- "Cape Verde"
trade[trade == "Congo"] <- "Republic of Congo"
trade[trade == "Cote d'Ivoire"] <- "Ivory Coast"
trade[trade == "Czechia"] <- "Czech Republic"
trade[trade == "Democratic People's Republic of Korea"] <- "North Korea"
trade[trade == "Eswatini"] <- "Swaziland"
trade[trade == "Guinea-Bissau"] <- "Guinea Bissau"
trade[trade == "Iran (Islamic Republic of)"] <- "Iran"
trade[trade == "Lao People's Democratic Republic"] <- "Laos"
trade[trade == "Micronesia (Federated States of)"] <- "Federated States of Micronesia"
trade[trade == "Netherlands Antilles (former)"] <- "Curaçao" # 0
trade[trade == "North Macedonia"] <- "Macedonia"
trade[trade == "Republic of Korea"] <- "South Korea"
trade[trade == "Republic of Moldova"] <- "Moldova"
trade[trade == "Russian Federation"] <- "Russia"
trade[trade == "Serbia"] <- "Republic of Serbia"
trade[trade == "Syrian Arab Republic"] <- "Syria"
trade[trade == "Timor-Leste"] <- "East Timor"
trade[trade == "Türkiye"] <- "Turkey"
trade[trade == "United Kingdom of Great Britain and Northern Ireland"] <- "United Kingdom"
trade[trade == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"
trade[trade == "Viet Nam"] <- "Vietnam"

# removing aggregate entry for China
trade = trade[-39,]

# removing entry with no data for former Sudan
trade = trade[-185,]

# left outer join between our df and the geographic data
borders <- left_join(borders, trade, by = c("ADMIN" = "country"))

# building the map

# setting the palette
palette <- colorBin("viridis", borders$qNorm)

# making labels
labels <- sprintf("<strong>%s</strong><br/>%s K MT", borders$ADMIN,
                  format(round(as.numeric(borders$quantity), 1), nsmall=1, big.mark=",")) %>%
  lapply(htmltools::HTML)

# entries for custom legend
legendLabels <- tibble(
  "0", "10,000,000", "30,000,000", "50,000,000", "70,000,000", "NA"
  )

# actual building
mapTrade <- leaflet(borders , options = leafletOptions(minZoom = 2.1), width = "100%") %>%
  addTiles() %>%
  setView(15, 20, 2) %>%
  addPolygons(
    data = borders, 
    color = '#ffffff', 
    weight = 1, 
    opacity = 0.5, 
    fillColor = ~palette(qNorm), 
    fillOpacity = 0.7, 
    highlight = highlightOptions(weight = 5), 
    label = labels
    ) %>%
  # legend
  addLegend("bottomright", pal = palette, values = ~qNorm, title = "Quantity (K MT)", opacity = 1, labFormat = 
              function(type, cuts, p) {paste0(legendLabels)}
            )

# building second map without China

# removing China outlier
borders$quantity[borders$ADMIN == "China"] <- NA

# normalization so that it works better with the palette but without distortion
minTrade <- min(borders$quantity, na.rm = TRUE)
maxTrade <- max(borders$quantity, na.rm = TRUE)
borders <- mutate(borders, qNorm =
                    (quantity - minTrade) / (maxTrade - minTrade))

# entries for custom legend
legendLabels <- tibble(
  "0", "2,000,000", "4,000,000", "6,000,000", "8,000,000", "NA"
  )

# actual building
mapTradeB <- leaflet(borders , options = leafletOptions(minZoom = 2.1), width = "100%") %>%
  addTiles() %>%
  setView(15, 20, 2) %>%
  addPolygons(
    data = borders, 
    color = '#ffffff', 
    weight = 1, 
    opacity = 0.5, 
    fillColor = ~palette(qNorm), 
    fillOpacity = 0.7, 
    highlight = highlightOptions(weight = 5), 
    label = labels
    ) %>%
  # legend
  addLegend("bottomright", pal = palette, values = ~qNorm, title = "Quantity (K MT)", opacity = 1, labFormat = 
              function(type, cuts, p) {paste0(legendLabels)}
            )
    

# building third map without Iran

# removing Iran outlier
borders$quantity[borders$ADMIN == "Iran"] <- NA

# normalization so that it works better with the palette but without distortion
minTrade <- min(borders$quantity, na.rm = TRUE)
maxTrade <- max(borders$quantity, na.rm = TRUE)
borders <- mutate(borders, qNorm =
                    (quantity - minTrade) / (maxTrade - minTrade))

# entries for custom legend
legendLabels <- tibble(
  "0", "1,500,000", "3,000,000", "4,500,000", "6,000,000", "NA"
  )

# actual building
mapTradeC <- leaflet(borders , options = leafletOptions(minZoom = 2.1), width = "100%") %>%
  addTiles() %>%
  setView(15, 20, 2) %>%
  addPolygons(
    data = borders, 
    color = '#ffffff', 
    weight = 1, 
    opacity = 0.5, 
    fillColor = ~palette(qNorm), 
    fillOpacity = 0.7, 
    highlight = highlightOptions(weight = 5), 
    label = labels
    ) %>%
  # legend
  addLegend("bottomright", pal = palette, values = ~qNorm, title = "Quantity (K MT)", opacity = 1, labFormat = 
              function(type, cuts, p) {paste0(legendLabels)}
            )
```

## Il Brasile

Concludiamo analizzando ora lo stato caratterizzato dal massimo BoT positivo.

Come sempre iniziamo mettendo qualche punto per poi mostrare alcuni modelli.

I dati per questa parte provengono dai dataset usati in precedenza e da uno nuovo.  
Nel dataset "Detailed Trade Matrix" vengono infatti descritti gli scambi commerciali tra i paesi.

Useremo questo dataset per costruire una mappa con la quale visualizzare le esportazioni del Brasile.

## Produzione

Il Brasile è uno dei principali produttori di cibo a livello mondiale.

```{r wProd, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table
production %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

## Export

Naturalmente figura anche tra i maggiori esportatori.

```{r wExp, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table
export %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

## La mappa mondiale dell'export brasiliano

```{r mapTrade, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

mapTrade
```

## La mappa mondiale dell'export brasiliano II

```{r mapTradeB, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

mapTradeB
```

## La mappa mondiale dell'export brasiliano III

```{r mapTradeC, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

mapTradeC
```

# Sustainability

```{r susCC, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# building dfs for issues of sustainability and climate change


# importing data (pesticides use)
pstc <- read_csv("./data/Inputs_Pesticides_Use_E_All_Data.csv") %>%
  select(Area, Item, Value) %>% # unit is kilo tonnes
  pivot_wider(names_from = Item, values_from = Value) %>%
  select(Area, `Pesticides (total)` ) %>%
  arrange(desc(`Pesticides (total)`)) %>%
  rename(country = Area, pesticides = `Pesticides (total)`) %>%
  # filtering redundant entry for China mainland
  filter(!(grepl('mainland', country)))

pstcP <- inner_join(pstc, production)

pstc[pstc == "Russian Federation"] <- "Russia"
pstc[pstc == "United States of America"] <- "USA"

# importing data (soil nutrient use)
sNu <- read_csv("./data/Environment_Soil_nutrient_budget_E_All_Data.csv") %>%
  select(Area, Element, Item, Unit, Value) %>%
   rename(
     country = Area,
     element = Element,
     item = Item,
     unit = Unit,
     value = Value
     )

sNu[sNu == "United States of America"] <- "USA"

sNupHa <- filter(sNu, element == "Cropland nutrient flow per unit area")

sNu <- filter(sNu, element == "Cropland nutrient flow") %>%
  select(- element, - unit) %>%
  pivot_wider(names_from = item, values_from = value) %>%
  arrange(desc(`Atmospheric Deposition`)) %>%
  rename(
    synthetic = `Synthetic Fertilizers`,
    manure = `Manure applied to Soils`,
    deposition = `Atmospheric Deposition`,
    cropRemoval = `Crop Removal`,
    bioFixation = `Biological Fixation`
  )

sNupHa <- select(sNupHa, -element, -unit) %>%
  group_by(country) %>%
  summarize(quantity = sum(value, na.rm = TRUE)) %>%
  arrange(desc(quantity))

sNupHa[sNupHa == "China, mainland"] <- "China"

sNup <- group_by(sNu, country) %>%
  summarize(quantity = sum(synthetic, manure, deposition, cropRemoval, bioFixation, na.rm = TRUE))

sNuP <- inner_join(sNup, production)

barPstc <- ggplot(data = pstc[1:10, ]) +
  geom_bar(stat = "identity", mapping = aes(x = country, y = pesticides, fill = country)) +
  scale_color_brewer(palette="Dark2") +
  #theme_dark() +
  labs(
    title = "Uso di pesticidi",
    subtitle = "Primi 10 paesi per uso (in MT)",
    caption = "Dati 2020"
  )

scatterPstcP <- ggplot(pstcP, aes(production, pesticides)) +
  geom_point(show.legend = FALSE) +
  geom_smooth(method = "lm") +
  labs(
    title = "Rapporto tra uso di pesticidi e produzione",
    subtitle = "L'uso di pesticidi è linearmente proporzionale alla produzione",
    caption = "Dati 2020"
  )

barSNupHa <- ggplot(data = sNupHa[1:7, ]) +
  geom_bar(stat = "identity", mapping = aes(x = country, y = quantity, fill = country)) +
  scale_color_brewer(palette="Dark2") +
  labs(
    title = "Uso di nutrienti per ettaro",
    subtitle = "Primi 7 paesi per uso di nutrienti per ettaro coltivato",
    caption = "Dati 2020"
  )

scatterSnuP <- ggplot(sNuP, aes(production, quantity)) +
  geom_point(show.legend = FALSE) +
  geom_smooth(method = "lm") +
  labs(
    title = "Rapporto tra uso di nutrienti e produzione",
    subtitle = "L'uso di nutrienti è linearmente proporzionale alla produzione",
    caption = "Dati 2020"
  )

# importing data (emission totals)
eTot <- read_csv("./data/Emissions_Totals_E_All_Data.csv") %>%
  select(Area, Element, Item, Value) %>%
  filter(!(grepl('mainland', Area))) %>%
  arrange(desc(`Value`)) %>%
  rename(
     country = Area,
     element = Element,
     item = Item,
     value = Value
     )
  
eTotKable <-  pivot_wider(eTot, names_from = item, values_from = value) %>%
  filter(element == "Emissions (CO2)") %>%
  select(country, `Net Forest conversion`, `Fires in organic soils`, `Drained organic soils (CO2)`, `On-farm energy use`, `Forestland`) %>%
  rename(
    forestConversion = `Net Forest conversion`,
    fires = `Fires in organic soils`,
    drainedCO2 = `Drained organic soils (CO2)`,
    farmEnergyUse = `On-farm energy use`,
    forest = `Forestland`
  )

# filtering redundant entry for China mainland
eTot <- filter(eTot, country == "China" | country == "India" | country == "China" | country == "Brazil" | country == "United States of America")

# building box plot to compare emissions from top food producing countries
boxProdEt <- ggplot(data = eTot[1:92,]) + #26, 28, 48, 69, 92
  geom_boxplot(mapping = aes(x = country, y = value,  fill = country)) +
  labs(
    title = "Emissioni nei maggiori produttori di cibo",
    subtitle = "Selezione delle fonti rilevanti",
    caption = "Dati 2020"
  ) +
  theme_classic()

# importing data (emissions, time)
eTime <- read_csv("./data/FAOSTAT_data_en_8-29-2022.csv") %>%
  rename(country = Area)

eTime <- inner_join(eTime, countryList)

eTime <- select(eTime, country, Element, Year, Value) %>%
  group_by(country, Year) %>%
  summarize(Value = sum(Value, na.rm = TRUE)) %>%
  pivot_wider(names_from = Year, values_from = Value) %>%
  arrange(desc(`2019`))

eTime <- pivot_longer(eTime, cols = - country,
    names_to = "year",
    names_prefix = "",
    values_to = "value"
  )

# margins
m <- list(
  l = 50,
  r = 50,
  b = 100,
  t = 100,
  pad = 4
)

scatterETime <- plot_ly(
  data = eTime[1:2950, ],
  x = ~country,
  y = ~`value`,
  frame = ~year,
  color = ~country,
  hovermode = "x",
  type = 'scatter',
  mode = 'markers',
  showlegend = FALSE,
  autosize = F, 
  width = 1000, 
  height = 500, 
  margin = m
  )

# layout
scatterETime <- scatterETime %>%
  layout(xaxis = list(title = 'Country', showticklabels=FALSE),
         yaxis = list(title = 'Tonnes'))
```

## Pesticidi

Il primo tema legato alla sostenibilità da affrontare è relativo ai pesticidi.

Quantità espresse in tonnellate.  
La tabella e il grafico successivo propongono una presentazione generale sul loro uso.

```{r pstc, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table
pstc %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

<br>

```{r barPstc, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

barPstc
```

## Pesticidi e produzione

Come abbiamo visto i maggiori stati produttori non coincidono esattamente con i maggiori utilizzatori di pesticidi.  
Questo ovviamente dipende dal tipo delle produzioni.

É comunque naturale aspettarsi che l'impiego di pesticidi sia linearmente proporzionale alla produzione.

```{r scatterPstcP, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterPstcP
```

## Nutrimento del suolo

Il nutrimento del suolo è il secondo aspetto relativo agli input e alla sostenibilità della produzione.

Quantità espresse in tonnellate.  
La tabella e il grafico successivo propongono una presentazione generale sul loro uso.

```{r sNu, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table
sNu %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

<br>

```{r barSNupHa, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

barSNupHa
```

## Nutrienti e produzione

Anche i maggiori utlilizzatori di nutrienti non coincidono con i maggiori stati produttori.

Resta però naturale aspettarsi che l’impiego di nutrienti sia linearmente proporzionale alla produzione.

```{r scatterSnuP, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterSnuP
```

## Emissioni

L'ultimo dataset che prenderemo in considerazione è relativo alle emissioni.

Quantità espresse in tonnellate.  
La tabella sottostante è relativa alle emissioni di CO2, organizzate per fonte.  
In questa tabella è riportato anche il dato relativo ai terreni forestali.  
FAO lo considera nel calcolo delle emissioni nette.

```{r eTotKable, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

# building table
eTotKable %>%
  mutate_if(is.numeric, funs(format(round(as.numeric(., 0), 1), nsmall=1, big.mark=","))) %>%
  kable() %>%
  kable_minimal(c("striped", "hover", "condensed", "responsive"), font_size = 15) %>%
  scroll_box(width = "100%", height = "450px")
```

<br>

Questo grafico ci permette di visualizzare la composizione delle emissioni nei principali stati produttori di cibo.

```{r boxProdEt, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

boxProdEt
```

## Emissioni nel tempo

Per concludere uno scatter plot per visualizzare l'andamento delle emissioni derivate dall'attività agricola nel corso del tempo.

```{r scatterETime, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}

scatterETime
```